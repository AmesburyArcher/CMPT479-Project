/*
 *  Copyright (c) 2014 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include "llvm_gen.h"

extern "C" {
  void wrapped_print_register(BitBlock bit_block) {
      print_register<BitBlock>("", bit_block);
  }
}

void LLVM_Generator::Print_Register(char *name, BitBlock bit_block)
{
    print_register<BitBlock>(name, bit_block);
}

LLVM_Generator::LLVM_Generator(std::string basis_pattern, int bits)
{
    mBasis_Pattern = basis_pattern;
    mBits = bits;
    mInWhile = false;
}

LLVM_Generator::~LLVM_Generator()
{
    delete mMod;
}

LLVM_Gen_RetVal LLVM_Generator::Generate_LLVMIR(CodeGenState cg_state, std::list<PabloS*> cc_cgo_stmtsl)
{
    //Create the module.
    MakeLLVMModule();

    //Create the jit execution engine.up
    InitializeNativeTarget();
    std::string ErrStr;
    mExecutionEngine = EngineBuilder(mMod).setUseMCJIT(true).setErrorStr(&ErrStr).setOptLevel(CodeGenOpt::Default).create();
    if (!mExecutionEngine)
    {
        std::cout << "\nCould not create ExecutionEngine: " + ErrStr << std::endl;
        exit(1);
    }

    InitializeNativeTargetAsmPrinter();
    InitializeNativeTargetAsmParser();

    DefineTypes();
    DeclareFunctions();

    Function::arg_iterator args = mFunc_process_block->arg_begin();
    Value* ptr_basis_bits = args++;
    ptr_basis_bits->setName("basis_bits");
    mptr_carry_q = args++;
    mptr_carry_q->setName("carry_q");
    Value* ptr_output = args++;
    ptr_output->setName("output");

    //Create the carry queue.
    mCarryQueueIdx = 0;

    mBasicBlock = BasicBlock::Create(mMod->getContext(), "parabix_entry", mFunc_process_block,0);

    //The basis bits structure
    mPtr_basis_bits_addr = new AllocaInst(mStruct_Basis_Bits_Ptr1, "basis_bits.addr", mBasicBlock);
    StoreInst* void_14 = new StoreInst(ptr_basis_bits, mPtr_basis_bits_addr, false, mBasicBlock);

    for (int i = 0; i < mBits; i++)
    {
        StoreBitBlockMarkerPtr(mBasis_Pattern + INT2STRING(i), i);
    }

    //The output structure.
    mPtr_output_addr = new AllocaInst(mStruct_Output_Ptr1, "output.addr", mBasicBlock);
    StoreInst* void_16 = new StoreInst(ptr_output, mPtr_output_addr, false, mBasicBlock);

    //Generate the IR instructions for the function.
    Generate_PabloStatements(cc_cgo_stmtsl);
    Generate_PabloStatements(cg_state.stmtsl);
    SetReturnMarker(cg_state.newsym, 0);
    SetReturnMarker("lex.cclf", 1);

    //Terminate the block
    ReturnInst::Create(mMod->getContext(), mBasicBlock);

    //Create a verifier.  The verifier will print an error message if our module is malformed in any way.
    verifyModule(*mMod, PrintMessageAction);

    //Un-comment this line in order to display the IR that has been generated by this module.
    //mMod->dump();

    //Use the pass manager to run optimizations on the function.
    FunctionPassManager fpm(mMod);

    // Set up the optimizer pipeline.  Start with registering info about how the target lays out data structures.
    fpm.add(new DataLayout(*mExecutionEngine->getDataLayout()));

    fpm.add(createPromoteMemoryToRegisterPass());

    fpm.doInitialization();

    fpm.run(*mFunc_process_block);

    //mMod->dump();

    mExecutionEngine->finalizeObject();

    LLVM_Gen_RetVal retVal;
    //Return the required size of the carry queue and a pointer to the process_block function.
    retVal.carry_q_size = LLVM_Generator_Helper::CarryCount_PabloStatements(cg_state.stmtsl);;
    retVal.process_block_fptr = mExecutionEngine->getPointerToFunction(mFunc_process_block);

    return retVal;
}

void LLVM_Generator::DefineTypes()
{
    //The BitBlock vector.
    m64x2Vect = VectorType::get(IntegerType::get(mMod->getContext(), 64), 2);
    //A pointer to the BitBlock vector.
    m64x2Vect_Ptr1 = PointerType::get(m64x2Vect, 0);

    //Constant definitions.
    mConst_int64_neg1 = ConstantInt::get(mMod->getContext(), APInt(64, StringRef("-1"), 10));

    mConst_Aggregate_64x2_0 = ConstantAggregateZero::get(m64x2Vect);
    std::vector<Constant*> const_packed_27_elems;
    const_packed_27_elems.push_back(mConst_int64_neg1);
    const_packed_27_elems.push_back(mConst_int64_neg1);
    mConst_Aggregate_64x2_neg1 = ConstantVector::get(const_packed_27_elems);


    StructType *StructTy_struct_Basis_bits = mMod->getTypeByName("struct.Basis_bits");
    if (!StructTy_struct_Basis_bits) {
        StructTy_struct_Basis_bits = StructType::create(mMod->getContext(), "struct.Basis_bits");
    }
    std::vector<Type*>StructTy_struct_Basis_bits_fields;
    for (int i = 0; i < mBits; i++)
    {
        StructTy_struct_Basis_bits_fields.push_back(m64x2Vect);
    }
    if (StructTy_struct_Basis_bits->isOpaque()) {
        StructTy_struct_Basis_bits->setBody(StructTy_struct_Basis_bits_fields, /*isPacked=*/false);
    }

    mStruct_Basis_Bits_Ptr1 = PointerType::get(StructTy_struct_Basis_bits, 0);

    std::vector<Type*>FuncTy_0_args;
    FuncTy_0_args.push_back(mStruct_Basis_Bits_Ptr1);

    //The carry q array.
    FuncTy_0_args.push_back(m64x2Vect_Ptr1);

    //The output structure.
    StructType *StructTy_struct_Output = mMod->getTypeByName("struct.Output");
    if (!StructTy_struct_Output) {
        StructTy_struct_Output = StructType::create(mMod->getContext(), "struct.Output");
    }
    std::vector<Type*>StructTy_struct_Output_fields;
    StructTy_struct_Output_fields.push_back(m64x2Vect);
    StructTy_struct_Output_fields.push_back(m64x2Vect);
    if (StructTy_struct_Output->isOpaque()) {
        StructTy_struct_Output->setBody(StructTy_struct_Output_fields, /*isPacked=*/false);
    }
    mStruct_Output_Ptr1 = PointerType::get(StructTy_struct_Output, 0);

    //The &output parameter.
    FuncTy_0_args.push_back(mStruct_Output_Ptr1);

    mFuncTy_0 = FunctionType::get(
     /*Result=*/Type::getVoidTy(mMod->getContext()),
     /*Params=*/FuncTy_0_args,
     /*isVarArg=*/false);
}

void LLVM_Generator::DeclareFunctions()
{
    //This function can be used for testing to print the contents of a register from JIT'd code to the terminal window.
    mFunc_print_register = mMod->getOrInsertFunction("wrapped_print_register", Type::getVoidTy(getGlobalContext()), m64x2Vect, NULL);
    mExecutionEngine->addGlobalMapping(cast<GlobalValue>(mFunc_print_register), (void *)&wrapped_print_register);

    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
        AttrBuilder B;
        B.addAttribute(Attribute::ReadOnly);
        B.addAttribute(Attribute::NoCapture);
        PAS = AttributeSet::get(mMod->getContext(), 1U, B);
    }
    Attrs.push_back(PAS);
    {
        AttrBuilder B;
        B.addAttribute(Attribute::NoCapture);
        PAS = AttributeSet::get(mMod->getContext(), 2U, B);
    }
    Attrs.push_back(PAS);
    {
        AttrBuilder B;
        B.addAttribute(Attribute::NoCapture);
        PAS = AttributeSet::get(mMod->getContext(), 3U, B);
    }
    Attrs.push_back(PAS);
    {
        AttrBuilder B;
        B.addAttribute(Attribute::NoUnwind);
        B.addAttribute(Attribute::UWTable);
        PAS = AttributeSet::get(mMod->getContext(), ~0U, B);
    }
    AttributeSet AttrSet = AttributeSet::get(mMod->getContext(), Attrs);

    //Create the function that will be generated.
    mFunc_process_block = mMod->getFunction("process_block");
    if (!mFunc_process_block) {
        mFunc_process_block = Function::Create(
            /*Type=*/mFuncTy_0,
            /*Linkage=*/GlobalValue::ExternalLinkage,
            /*Name=*/"process_block", mMod);
        mFunc_process_block->setCallingConv(CallingConv::C);
    }
    mFunc_process_block->setAttributes(AttrSet);
}

void LLVM_Generator::MakeLLVMModule()
{
    mMod = new Module("icgrep", getGlobalContext());
    mMod->setDataLayout("e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128");
    mMod->setTargetTriple("x86_64-unknown-linux-gnu");
}

void LLVM_Generator::StoreBitBlockMarkerPtr(std::string name, int index)
{
    IRBuilder<> b(mBasicBlock);

    Value* basis_bits_struct = b.CreateLoad(mPtr_basis_bits_addr);
    Value* struct_indices[] = {b.getInt64(0), b.getInt32(index)};
    Value* basis_bits_struct_GEP = b.CreateGEP(basis_bits_struct, struct_indices, name);
    mMarkerMap.insert(make_pair(name, basis_bits_struct_GEP));
}

Value* LLVM_Generator::GetMarker(std::string name)
{
    IRBuilder<> b(mBasicBlock);

    if (mMarkerMap.find(name) == mMarkerMap.end())
    {       
        Value* ptr = b.CreateAlloca(m64x2Vect);
        Value* void_1 = b.CreateStore(mConst_Aggregate_64x2_0, ptr);
        mMarkerMap.insert(make_pair(name, ptr));
    }
    std::map<std::string, Value*>::iterator itGet = mMarkerMap.find(name);

    return itGet->second;
}

void LLVM_Generator::SetReturnMarker(std::string marker, int output_idx)
{
    IRBuilder<> b(mBasicBlock);

    Value* marker_bitblock = b.CreateLoad(GetMarker(marker));
    Value* output_struct = b.CreateLoad(mPtr_output_addr);
    Value* output_indices[] = {b.getInt64(0), b.getInt32(output_idx)};
    Value* output_struct_GEP = b.CreateGEP(output_struct, output_indices, "return" + marker);
    Value* store_marker = b.CreateStore(marker_bitblock, output_struct_GEP);
}

std::string LLVM_Generator::Generate_PabloStatements(std::list<PabloS*> stmts)
{
    std::string retVal = "";

    std::list<PabloS*>::iterator it;
    for (it = stmts.begin(); it != stmts.end(); ++it)
    {
        retVal = Generate_PabloS(*it);
    }

    return retVal;
}

std::string LLVM_Generator::Generate_PabloS(PabloS *stmt)
{
    std::string retVal = "";

    if (Assign* assign = dynamic_cast<Assign*>(stmt))
    {
        IRBuilder<> b(mBasicBlock);

        b.CreateStore(Generate_PabloE(assign->getExpr()), GetMarker(assign->getM()));

        retVal = assign->getM();
    }
    else if (While* whl = dynamic_cast<While*>(stmt))
    {
        IRBuilder<> b(mBasicBlock);

        mWhileCondBlock = BasicBlock::Create(mMod->getContext(), "while.cond", mFunc_process_block, 0);
        mWhileBodyBlock = BasicBlock::Create(mMod->getContext(), "while.body",mFunc_process_block, 0);
        mWhileEndBlock = BasicBlock::Create(mMod->getContext(), "while.end",mFunc_process_block, 0);

        int idx = mCarryQueueIdx;

        std::string returnMarker = Generate_PabloStatements(whl->getPSList());

        b.CreateBr(mWhileCondBlock);
        mBasicBlock = mWhileCondBlock;
        IRBuilder<> b_cond(mWhileCondBlock);

        Value* expression_marker_value = Generate_PabloE(whl->getExpr());
        
        // Use an i128 compare for simplicity and speed.
        Value* cast_marker_value_1 = b_cond.CreateBitCast(expression_marker_value, IntegerType::get(mMod->getContext(), 128));
        Value* int_tobool1 = b_cond.CreateICmpEQ(cast_marker_value_1, ConstantInt::get(IntegerType::get(mMod->getContext(), 128), 0));
        b_cond.CreateCondBr(int_tobool1, mWhileEndBlock, mWhileBodyBlock);

        //Note: Everything that happens during the recursive calls for the pablo statements in the body of this while loop will
        //happen within the basic block of the body of the while loop.  This strategy will not support kstars within
        //kstars, a more complex stragegy for basicblocks will have to be devised for that.
        mBasicBlock = mWhileBodyBlock;

        mInWhile = true;
        mCarryQueueIdx = idx;
        returnMarker = Generate_PabloStatements(whl->getPSList());
        mInWhile = false;
        IRBuilder<> b_wb(mWhileBodyBlock);
        b_wb.CreateBr(mWhileCondBlock);

        mBasicBlock = mWhileEndBlock;

        retVal = returnMarker;
    }

    return retVal;
}

Value* LLVM_Generator::Generate_PabloE(PabloE *expr)
{
    Value* retVal = 0;

    if (All* all = dynamic_cast<All*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        if ((all->getNum() != 0) && (all->getNum() != 1))
            std::cout << "\nErr: 'All' can only be set to 1 or 0.\n" << std::endl;
        Value* ptr_all = b.CreateAlloca(m64x2Vect);
        Value* void_1 = b.CreateStore((all->getNum() == 0 ? mConst_Aggregate_64x2_0 : mConst_Aggregate_64x2_neg1), ptr_all);
        Value* all_value = b.CreateLoad(ptr_all);

        retVal = all_value;
    }
    else if (Var* var = dynamic_cast<Var*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        Value* var_value = b.CreateLoad(GetMarker(var->getVar()), false, var->getVar());

        retVal = var_value;
    }
    else if (And* pablo_and = dynamic_cast<And*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        Value* and_result = b.CreateAnd(Generate_PabloE(pablo_and->getExpr1()), Generate_PabloE(pablo_and->getExpr2()), "and_inst");

        retVal = and_result;
    }
    else if (Or* pablo_or = dynamic_cast<Or*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        Value* or_result = b.CreateOr(Generate_PabloE(pablo_or->getExpr1()), Generate_PabloE(pablo_or->getExpr2()), "or_inst");

        retVal = or_result;
    }
    else if (Sel* pablo_sel = dynamic_cast<Sel*>(expr))
    {
        IRBuilder<>b(mBasicBlock);

        Value* and_if_true_result = b.CreateAnd(Generate_PabloE(pablo_sel->getIf_expr()), Generate_PabloE(pablo_sel->getT_expr()));
        Constant* const_packed_elems [] = {b.getInt64(-1), b.getInt64(-1)};
        Constant* const_packed = ConstantVector::get(const_packed_elems);
        Value* not_if_result = b.CreateXor(Generate_PabloE(pablo_sel->getIf_expr()), const_packed);
        Value* and_if_false_result = b.CreateAnd(not_if_result, Generate_PabloE(pablo_sel->getF_expr()));
        Value* or_result = b.CreateOr(and_if_true_result, and_if_false_result);

        retVal = or_result;
    }
    else if (Not* pablo_not = dynamic_cast<Not*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        Constant* const_packed_elems [] = {b.getInt64(-1), b.getInt64(-1)};
        Constant* const_packed = ConstantVector::get(const_packed_elems);
        Value* expr_value = Generate_PabloE(pablo_not->getExpr());
        Value* xor_rslt = b.CreateXor(expr_value, const_packed, "xor_inst");

        retVal = xor_rslt;
    }
    else if (CharClass* cc = dynamic_cast<CharClass*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        Value* character_class = b.CreateLoad(GetMarker(cc->getCharClass()));

        retVal = character_class;
    }
    else if (Advance* adv = dynamic_cast<Advance*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        //CarryQ - carry in.
        Value* carryq_idx = b.getInt64(mCarryQueueIdx);
        Value* carryq_GEP = b.CreateGEP(mptr_carry_q, carryq_idx);
        Value* carryq_value = b.CreateLoad(carryq_GEP);

        Value* strm_value = Generate_PabloE(adv->getExpr());
        Value* srli_1_value = b.CreateLShr(strm_value, 63);

        Value* packed_shuffle;
        if (mInWhile)
        {
            Constant* const_packed_1_elems [] = {b.getInt32(0), b.getInt32(2)};
            Constant* const_packed_1 = ConstantVector::get(const_packed_1_elems);
            packed_shuffle = b.CreateShuffleVector(mConst_Aggregate_64x2_0, srli_1_value, const_packed_1, "packed_shuffle iw");
        }
        else
        {
            Constant* const_packed_1_elems [] = {b.getInt32(0), b.getInt32(2)};
            Constant* const_packed_1 = ConstantVector::get(const_packed_1_elems);
            packed_shuffle = b.CreateShuffleVector(carryq_value, srli_1_value, const_packed_1, "packed_shuffle nw");
        }

        Constant* const_packed_2_elems[] = {b.getInt64(1), b.getInt64(1)};
        Constant* const_packed_2 = ConstantVector::get(const_packed_2_elems);

        Value* shl_value = b.CreateShl(strm_value, const_packed_2, "shl_value");
        Value* result_value = b.CreateOr(shl_value, packed_shuffle, "or.result_value");

        //CarryQ - carry out.
        Value* cast_marker_value_1 = b.CreateBitCast(strm_value, IntegerType::get(mMod->getContext(), 128));
        Value* srli_2_value = b.CreateLShr(cast_marker_value_1, 127);
        Value* carryout_2_carry = b.CreateBitCast(srli_2_value, m64x2Vect);

        if (mInWhile)
        {
            Value* carryout = b.CreateOr(carryq_value, carryout_2_carry);
            Value* void_1 = b.CreateStore(carryout, carryq_GEP);
        }
        else
        {
            Value* void_1 = b.CreateStore(carryout_2_carry, carryq_GEP);
        }

        //Increment the idx for the next advance or scan through.
        mCarryQueueIdx++;

        retVal = result_value;
    }
    else if (MatchStar* mstar = dynamic_cast<MatchStar*>(expr))
    {
        IRBuilder<> b(mBasicBlock);

        //CarryQ - carry in.
        Value* carryq_idx = b.getInt64(mCarryQueueIdx);
        Value* carryq_GEP = b.CreateGEP(mptr_carry_q, carryq_idx);
        Value* carryq_value = b.CreateLoad(carryq_GEP);
        //Get the input stream.
        Value* strm_value = Generate_PabloE(mstar->getExpr1());
        //Get the character that is to be matched.
        Value* cc_value = Generate_PabloE(mstar->getExpr2());

        Value* and_value_1 = b.CreateAnd(cc_value, strm_value, "match_star_and_value_1");
        Value* add_value_1 = b.CreateAdd(and_value_1, cc_value, "match_star_add_value_1");
        Value* add_value_2 = b.CreateAdd(add_value_1, carryq_value, "match_star_add_value_2");
        Value* xor_value_1 = b.CreateXor(add_value_2, mConst_Aggregate_64x2_neg1, "match_star_xor_value_1");
        Value* and_value_2 = b.CreateAnd(cc_value, xor_value_1, "match_star_and_value_2");
        Value* or_value_1 = b.CreateOr(and_value_1, and_value_2, "match_star_or_value_1");

        Value* srli_instr_1 = b.CreateLShr(or_value_1, 63);

        Value* cast_marker_value_1 = b.CreateBitCast(srli_instr_1, IntegerType::get(mMod->getContext(), 128));
        Value* sll_1_value = b.CreateShl(cast_marker_value_1, 64);
        Value* cast_marker_value_2 = b.CreateBitCast(sll_1_value, m64x2Vect);


        Value* add_value_3 = b.CreateAdd(cast_marker_value_2, add_value_2, "match_star_add_value_3");
        Value* xor_value_2 = b.CreateXor(add_value_3, mConst_Aggregate_64x2_neg1, "match_star_xor_value_2");
        Value* and_value_3 = b.CreateAnd(cc_value, xor_value_2, "match_star_and_value_3");
        Value* or_value_2  = b.CreateOr(and_value_1, and_value_3, "match_star_or_value_2 ");
        Value* xor_value_3 = b.CreateXor(add_value_3, cc_value, "match_star_xor_value_3");
        Value* result_value = b.CreateOr(xor_value_3, strm_value, "match_star_result_value");

        //CarryQ - carry out:
        Value* cast_marker_value_3 = b.CreateBitCast(or_value_2, IntegerType::get(mMod->getContext(), 128));
        Value* srli_2_value = b.CreateLShr(cast_marker_value_3, 127);
        Value* carryout_2_carry = b.CreateBitCast(srli_2_value, m64x2Vect);

        Value* void_1 = b.CreateStore(carryout_2_carry, carryq_GEP);

        mCarryQueueIdx++;

        retVal = result_value;
    }

    return retVal;
}

