/*
 *  Copyright (c) 2015 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include <string>
#include <iostream>
#include <fstream>

#include <re/re_toolchain.h>
#include <re/re_cc.h>
#include <re/re_nullable.h>
#include <re/re_simplifier.h>
#include <re/re_alt.h>
#include <re/parsefailure.h>
#include <re/re_parser.h>
#include <re/re_compiler.h>
#include <utf8_encoder.h>
#include <cc/cc_compiler.h>
#include <pablo/function.h>
#include <re/printer_re.h>
#include <llvm/Support/CommandLine.h>


using namespace pablo;
namespace re {

static cl::OptionCategory RegexOptions("Regex Toolchain Options",
                                              "These options control the regular expression transformation and compilation.");
const cl::OptionCategory * re_toolchain_flags() {return &RegexOptions;};

static cl::bits<RE_PrintFlags> 
    PrintOptions(cl::values(clEnumVal(PrintAllREs, "print regular expression passes"),
                            clEnumVal(PrintParsedREs, "print out parsed regular expressions"),
                            clEnumVal(PrintStrippedREs, "print out REs with nullable prefixes/suffixes removed"),
                            clEnumVal(PrintSimplifiedREs, "print out final simplified REs"),
                            clEnumValEnd), cl::cat(RegexOptions));

static cl::bits<RE_AlgorithmFlags>
    AlgorithmOptions(cl::values(clEnumVal(DisableLog2BoundedRepetition, "disable log2 optimizations for bounded repetition of bytes"),
                              clEnumVal(DisableIfHierarchy, "disable nested if hierarchy for generated Unicode classes (not recommended)"), 
                              clEnumVal(DisableMatchStar, "disable MatchStar optimization"), 
                              clEnumVal(DisableUnicodeMatchStar, "disable Unicode MatchStar optimization"),
                              clEnumVal(DisableUnicodeLineBreak, "disable Unicode line breaks - use LF only"),
                              clEnumValN(InvertMatches, "v", "select non-matching lines"),
#ifndef DISABLE_PREGENERATED_UCD_FUNCTIONS
                              clEnumVal(UsePregeneratedUnicode, "use fixed pregenerated Unicode character class sets instead"),
#endif
                              clEnumValEnd), 
                   cl::cat(RegexOptions));

bool AlgorithmOptionIsSet(RE_AlgorithmFlags flag) {
    return AlgorithmOptions.isSet(flag);
}

int IfInsertionGap;
static cl::opt<int, true> 
    IfInsertionGapOption("if-insertion-gap",  cl::location(IfInsertionGap), cl::init(3),
                         cl::desc("minimum number of nonempty elements between inserted if short-circuit tests"), 
                         cl::cat(RegexOptions));



RE * regular_expression_passes(const Encoding encoding, RE * re_ast)  {
    if (PrintOptions.isSet(PrintAllREs) || PrintOptions.isSet(PrintParsedREs)) {
        std::cerr << "Parser:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;
    }

    //Optimization passes to simplify the AST.
    re_ast = re::RE_Nullable::removeNullablePrefix(re_ast);
    if (PrintOptions.isSet(PrintAllREs) || PrintOptions.isSet(PrintStrippedREs)) {
        std::cerr << "RemoveNullablePrefix:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;
    }
    re_ast = re::RE_Nullable::removeNullableSuffix(re_ast);
    if (PrintOptions.isSet(PrintAllREs) || PrintOptions.isSet(PrintStrippedREs)) {
        std::cerr << "RemoveNullableSuffix:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;
    }

    re_ast = re::RE_Simplifier::simplify(re_ast);
    if (PrintOptions.isSet(PrintAllREs) || PrintOptions.isSet(PrintSimplifiedREs)) {
        //Print to the terminal the AST that was generated by the simplifier.
        std::cerr << "Simplifier:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;
    }
    return re_ast;
}
    
PabloFunction * re2pablo_compiler(const Encoding encoding, RE * re_ast) {
    PabloFunction * function = PabloFunction::Create("process_block", 8, 2);
    cc::CC_Compiler cc_compiler(*function, encoding);
    re::RE_Compiler re_compiler(*function, cc_compiler);
    re_compiler.initializeRequiredStreams();
    re_compiler.compileUnicodeNames(re_ast);
    re_compiler.finalizeMatchResult(re_compiler.compile(re_ast), AlgorithmOptions.isSet(InvertMatches));
    return function;
}
}
