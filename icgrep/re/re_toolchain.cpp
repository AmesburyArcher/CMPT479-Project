/*
 *  Copyright (c) 2017 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include <toolchain/toolchain.h>
#include <grep_interface.h>
#include <re/re_toolchain.h>
#include <re/re_any.h>
#include <re/re_name.h>
#include <re/re_cc.h>
#include <re/re_start.h>
#include <re/re_end.h>
#include <re/re_alt.h>
#include <re/re_seq.h>
#include <re/re_diff.h>
#include <re/re_intersect.h>
#include <re/re_group.h>
#include <re/re_range.h>
#include <re/re_assertion.h>
#include <cc/cc_compiler.h>            // for CC_Compiler
#include <llvm/Support/CommandLine.h>  // for clEnumVal, clEnumValEnd, Optio...
#include <re/re_compiler.h>            // for RE_Compiler
#include <re/re_nullable.h>            // for RE_Nullable
#include <re/re_star_normal.h>         // for RE_Star_Normal
#include <re/re_simplifier.h>          // for RE_Simplifier
#include <re/re_minimizer.h>
#include <re/re_local.h>
#include <re/printer_re.h>
#include <re/re_analysis.h>
#include <re/re_cc.h>
#include <re/casing.h>
#include <re/exclude_CC.h>
#include <re/re_name_resolve.h>
#include <re/grapheme_clusters.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/ErrorHandling.h>
#include <toolchain/toolchain.h>

using namespace pablo;
using namespace llvm;

namespace re {

static cl::OptionCategory RegexOptions("Regex Toolchain Options",
                                              "These options control the regular expression transformation and compilation.");
const cl::OptionCategory * LLVM_READONLY re_toolchain_flags() {
    return &RegexOptions;
}

static cl::bits<RE_PrintFlags> 
    PrintOptions(cl::values(clEnumVal(ShowREs, "Print parsed or generated regular expressions"),
                            clEnumVal(ShowAllREs, "Print all regular expression passes"),
                            clEnumVal(ShowStrippedREs, "Print REs with nullable prefixes/suffixes removed"),
                            clEnumVal(ShowSimplifiedREs, "Print final simplified REs")
                            CL_ENUM_VAL_SENTINEL), cl::cat(RegexOptions));

static cl::bits<RE_AlgorithmFlags>
    AlgorithmOptions(cl::values(clEnumVal(DisableLog2BoundedRepetition, "disable log2 optimizations for bounded repetition of bytes"),
                              clEnumVal(DisableIfHierarchy, "disable nested if hierarchy for generated Unicode classes (not recommended)"), 
                              clEnumVal(DisableMatchStar, "disable MatchStar optimization"), 
                              clEnumVal(DisableUnicodeMatchStar, "disable Unicode MatchStar optimization"),
                              clEnumVal(DisableUnicodeLineBreak, "disable Unicode line breaks - use LF only")
                              CL_ENUM_VAL_SENTINEL), cl::cat(RegexOptions));

bool LLVM_READONLY AlgorithmOptionIsSet(RE_AlgorithmFlags flag) {
    return AlgorithmOptions.isSet(flag);
}

int IfInsertionGap;
static cl::opt<int, true> 
    IfInsertionGapOption("if-insertion-gap",  cl::location(IfInsertionGap), cl::init(3),
                         cl::desc("minimum number of nonempty elements between inserted if short-circuit tests"), 
                         cl::cat(RegexOptions));

RE * resolveModesAndExternalSymbols(RE * r, bool globallyCaseInsensitive) {
    if (PrintOptions.isSet(ShowAllREs) || PrintOptions.isSet(ShowREs)) {
        errs() << "Parser:\n" << Printer_RE::PrintRE(r) << '\n';
    }
    r = resolveGraphemeMode(r, false /* not in grapheme mode at top level*/);
    if (PrintOptions.isSet(ShowAllREs)) {
        errs() << "resolveGraphemeMode:\n" << Printer_RE::PrintRE(r) << '\n';
    }
    r = re::resolveUnicodeNames(r);
    r = resolveCaseInsensitiveMode(r, globallyCaseInsensitive);
    return r;
}

RE * excludeUnicodeLineBreak(RE * r) {
    r = exclude_CC(r, re::makeCC(re::makeCC(0x0A, 0x0D), re::makeCC(re::makeCC(0x85), re::makeCC(0x2028, 0x2029))));
    if (PrintOptions.isSet(ShowAllREs)) {
        errs() << "excludeUnicodeLineBreak:\n" << Printer_RE::PrintRE(r) << '\n';
    }
    return r;
}

RE * regular_expression_passes(RE * r) {

    //Optimization passes to simplify the AST.
    r = RE_Nullable::removeNullablePrefix(r);
    if (PrintOptions.isSet(ShowAllREs) || PrintOptions.isSet(ShowStrippedREs)) {
        errs() << "RemoveNullablePrefix:\n" << Printer_RE::PrintRE(r) << '\n';
    }
    r = RE_Nullable::removeNullableSuffix(r);
    if (PrintOptions.isSet(ShowAllREs) || PrintOptions.isSet(ShowStrippedREs)) {
        errs() << "RemoveNullableSuffix:\n" << Printer_RE::PrintRE(r) << '\n';
    }
    r = RE_Star_Normal().transformRE(r);
    if (codegen::OptLevel > 1) {
        r = RE_Minimizer::minimize(r);
    } else {
        r = RE_Simplifier::simplify(r);
    }
    if (PrintOptions.isSet(ShowAllREs) || PrintOptions.isSet(ShowSimplifiedREs)) {
        //Print to the terminal the AST that was generated by the simplifier.
        errs() << "Simplifier:\n" << Printer_RE::PrintRE(r) << '\n';
    }

    if (!DefiniteLengthBackReferencesOnly(r)) {
        llvm::report_fatal_error("Future back reference support: references must be within a fixed distance from a fixed-length capture.");
    }
    return r;
}
RE * RE_Transformer::transformRE(RE * re) {
    RE * initialRE = re;
    RE * finalRE = transform(re);
    if (PrintOptions.isSet(ShowAllREs) && (initialRE != finalRE) && (mTransformationName != "")) {
        errs() << mTransformationName << ":\n" << Printer_RE::PrintRE(finalRE) << '\n';
    }
    return finalRE;
}

RE * RE_Transformer::transform(RE * re) {
    if (llvm::isa<CC>(re)) return transformCC(llvm::cast<CC>(re));
    else if (llvm::isa<Start>(re)) return transformStart(llvm::cast<Start>(re));
    else if (llvm::isa<End>(re)) return transformEnd(llvm::cast<End>(re));
    else if (llvm::isa<Name>(re)) return transformName(llvm::cast<Name>(re));
    else if (llvm::isa<Seq>(re)) return transformSeq(llvm::cast<Seq>(re));
    else if (llvm::isa<Alt>(re)) return transformAlt(llvm::cast<Alt>(re));
    else if (llvm::isa<Rep>(re)) return transformRep(llvm::cast<Rep>(re));
    else if (llvm::isa<Intersect>(re)) return transformIntersect(llvm::cast<Intersect>(re));
    else if (llvm::isa<Diff>(re)) return transformDiff(llvm::cast<Diff>(re));
    else if (llvm::isa<Range>(re)) return transformRange(llvm::cast<Range>(re));
    else if (llvm::isa<Group>(re)) return transformGroup(llvm::cast<Group>(re));
    else if (llvm::isa<Assertion>(re)) return transformAssertion(llvm::cast<Assertion>(re));
    else {
        llvm_unreachable("Unknown RE type");
        return nullptr;
    }
}

RE * RE_Transformer::transformName(Name * nm) {
    if (mNameTransform == NameTransformationMode::None) return nm;
    RE * d = nm->getDefinition();
    if (d) return transform(d);
    UndefinedNameError(nm);
    return nullptr;
}

RE * RE_Transformer::transformCC(CC * cc) {
    return cc;
}

RE * RE_Transformer::transformStart(Start * s) {
    return s;
}

RE * RE_Transformer::transformEnd(End * e) {
    return e;
}

RE * RE_Transformer::transformSeq(Seq * seq) {
    std::vector<RE *> elems;
    elems.reserve(seq->size());
    bool any_changed = false;
    for (RE * e : *seq) {
        RE * e1 = transform(e);
        if (e1 != e) any_changed = true;
        elems.push_back(e1);
    }
    if (!any_changed) return seq;
    return makeSeq(elems.begin(), elems.end());
}

RE * RE_Transformer::transformAlt(Alt * alt) {
    std::vector<RE *> elems;
    elems.reserve(alt->size());
    bool any_changed = false;
    for (RE * e : *alt) {
        RE * e1 = transform(e);
        if (e1 != e) any_changed = true;
        elems.push_back(e1);
    }
    if (!any_changed) return alt;
    return makeAlt(elems.begin(), elems.end());
}

RE * RE_Transformer::transformRep(Rep * r) {
    RE * x0 = r->getRE();
    RE * x = transform(x0);
    if (x == x0) {
        return r;
    } else {
        return makeRep(x, r->getLB(), r->getUB());
    }
}

RE * RE_Transformer::transformIntersect(Intersect * ix) {
    RE * x0 = ix->getLH();
    RE * y0 = ix->getRH();
    RE * x = transform(x0);
    RE * y = transform(y0);
    if ((x == x0) && (y == y0)) {
        return ix;
    } else {
        return makeIntersect(x, y);
    }
}

RE * RE_Transformer::transformDiff(Diff * d) {
    RE * x0 = d->getLH();
    RE * y0 = d->getRH();
    RE * x = transform(x0);
    RE * y = transform(y0);
    if ((x == x0) && (y == y0)) {
        return d;
    } else {
        return makeDiff(x, y);
    }
}

RE * RE_Transformer::transformRange(Range * rg) {
    RE * x0 = rg->getLo();
    RE * y0 = rg->getHi();
    RE * x = transform(x0);
    RE * y = transform(y0);
    if ((x == x0) && (y == y0)) {
        return rg;
    } else {
        return makeRange(x, y);
    }
}

RE * RE_Transformer::transformGroup(Group * g) {
    RE * x0 = g->getRE();
    RE * x = transform(x0);
    if (x == x0) {
        return g;
    } else {
        return makeGroup(g->getMode(), x, g->getSense());
    }
}

RE * RE_Transformer::transformAssertion(Assertion * a) {
    RE * x0 = a->getAsserted();
    RE * x = transform(x0);
    if (x == x0) {
        return a;
    } else {
        return makeAssertion(x, a->getKind(), a->getSense());
    }
}

}
