/*
 *  Copyright (c) 2014 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include "re_compiler.h"
#include "re_alt.h"
#include "re_cc.h"
#include "re_name.h"
#include "re_end.h"
#include "re_rep.h"
#include "re_seq.h"
#include "re_start.h"
#include "re_nullable.h"
#include "re_simplifier.h"
#include "re_reducer.h"
#include "parsefailure.h"
#include "re_parser.h"

#include "../hrtime.h"

#include "../printer_pablos.h"
#include "../printer_re.h"

#include "../utf8_encoder.h"
#include "../cc_compiler.h"
#include "../pbix_compiler.h"
#include "../symbol_generator.h"

//FOR TESTING AND AND ANALYSIS
//#include "pbix_counter.h"


RE_Compiler::RE_Compiler(){}

LLVM_Gen_RetVal RE_Compiler::compile(bool show_compile_time,
                                     bool ascii_only,
                                     std::string basis_pattern,
                                     std::string gensym_pattern,
                                     UTF_Encoding encoding,
                                     std::string input_string)
{
    CC_Compiler cc_compiler(encoding, basis_pattern, gensym_pattern);

//    std::cerr << "============================================================================" << std::endl;
//    std::cerr << input_string << std::endl;
//    std::cerr << "============================================================================" << std::endl;

    RE* re_ast = nullptr;
    try
    {
        re_ast = RE_Parser::parse_re(input_string);
    }
    catch (ParseFailure failure)
    {
        std::cerr << "REGEX PARSING FAILURE: " << failure.what() << std::endl;
        exit(1);
    }

    //Print to the terminal the AST that was generated by the parser before adding the UTF encoding:
    // std::cerr << "Parser:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;

    //Add the UTF encoding.
    if (!ascii_only)
    {
        if (encoding.getName().compare("UTF-8") == 0)
        {
            re_ast = UTF8_Encoder::toUTF8(re_ast);
        }
        else
        {
            std::cerr << "Invalid encoding!" << std::endl;
            exit(1);
        }
    }

    //Print to the terminal the AST that was generated by the utf8 encoder.
    // std::cerr << "UTF8-encoder:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;

    //Optimization passes to simplify the AST.
    re_ast = RE_Nullable::removeNullablePrefix(re_ast);

    re_ast = RE_Nullable::removeNullableSuffix(re_ast);

    re_ast = RE_Simplifier::simplify(re_ast);

    //Print to the terminal the AST that was generated by the simplifier.
    // std::cout << "\nSimplifier:\n" + Printer_RE::PrintRE(re_ast) + "\n" << std::endl;

    //Map all of the unique character classes in order to reduce redundancy.
    std::map<std::string, RE*> re_map;
    re_ast = RE_Reducer::reduce(re_ast, re_map);

    //Print to the terminal the AST with the reduced REs.
    // std::cerr << "Reducer:" << std::endl << Printer_RE::PrintRE(re_ast) << std::endl;

    //Build our list of predefined characters.
    std::string cc_name;
    std::map<std::string,std::string> name_map;

    CC* cc_lf = new CC(0x0A);
    cc_name = cc_lf->getName();
    re_map.insert(make_pair(cc_name, cc_lf));
    name_map.insert(make_pair("LineFeed", cc_name));

    CC* cc_utf8_single_byte = new CC(0x00, 0x7F);
    cc_name = cc_utf8_single_byte->getName();
    re_map.insert(make_pair(cc_name, cc_utf8_single_byte));
    name_map.insert(make_pair("UTF8-SingleByte", cc_name));

    CC* cc_utf8_prefix2 = new CC(0xC2, 0xDF);
    cc_name = cc_utf8_prefix2->getName();
    re_map.insert(make_pair(cc_name, cc_utf8_prefix2));
    name_map.insert(make_pair("UTF8-Prefix2", cc_name));

    CC* cc_utf8_prefix3 = new CC(0xE0, 0xEF);
    cc_name = cc_utf8_prefix3->getName();
    re_map.insert(make_pair(cc_name, cc_utf8_prefix3));
    name_map.insert(make_pair("UTF8-Prefix3", cc_name));

    CC* cc_utf8_prefix4 = new CC(0xF0, 0xF4);
    cc_name = cc_utf8_prefix4->getName();
    re_map.insert(make_pair(cc_name, cc_utf8_prefix4));
    name_map.insert(make_pair("UTF8-Prefix4", cc_name));

    cc_compiler.compile_from_map(re_map);
    std::list<PabloS*> cc_stmtsl = cc_compiler.get_compiled();
    //Print to the terminal the AST that was generated by the character class compiler.
    // std::cerr << "CC AST:" << std::endl << StatementPrinter::Print_CC_PabloStmts(cc_stmtsl) << std::endl;

    Pbix_Compiler pbix_compiler(name_map);
    CodeGenState re_subexpression_cg_state = pbix_compiler.compile_subexpressions(re_map);
    //Print to the terminal the AST that was generated for the re subexpressions.
    // std::cerr << "\n" << "Subexpressions: (" << StatementPrinter::PrintStmts(re_subexpression_cg_state) << ")" << std::endl;

    CodeGenState re_cg_state = pbix_compiler.compile(re_ast);
    //Print to the terminal the AST that was generated by the pararallel bit-stream compiler.
    // std::cerr << "\n" << "(" << StatementPrinter::PrintStmts(re_cg_state) << ")" << "\n" << std::endl;

    //Print a count of the Pablo statements and expressions that are contained in the AST from the pbix compiler.
    //std::cout << "\nPablo Statement Count: " << Pbix_Counter::Count_PabloStatements(re_cg_state.stmtsl) <<  "\n" << std::endl;

    LLVM_Generator irgen(name_map, basis_pattern, encoding.getBits());

    unsigned long long cycles = 0;
    double timer = 0;
    if (show_compile_time)
    {
        cycles = get_hrcycles();
        timer = getElapsedTime();
    }

    LLVM_Gen_RetVal retVal = irgen.Generate_LLVMIR(re_cg_state, re_subexpression_cg_state, cc_stmtsl);
    if (show_compile_time)
    {
        cycles = get_hrcycles() - cycles;
        timer = getElapsedTime() - timer;
        std::cout << "LLVM compile time -  cycles:       " << cycles  << std::endl;
        std::cout << "LLVM compile time -  milliseconds: " << timer << std::endl;
    }

    return  retVal;  //irgen.Generate_LLVMIR(re_cg_state, cc_stmtsl);
}

