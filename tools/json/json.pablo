#
# Copyright (c) 2019 International Characters.
# This software is licensed to the public under the Open Software License 3.0.
#

type BasisBits = <i1>[8]

type Err = <i1>[2] {
    escapedStr,
    utf8
}

type Lex = <i1>[14] {
    lCurly,
    rCurly,
    lBracket,
    rBracket,
    colon,
    comma,
    dQuote,
    hyphen,
    digit,
    backslash,
    n, # first letter of null
    f, # first letter of false
    t, # first letter of true
    ws
}

# ClassifyBytes the bytes of a basis stream.
# See that there is no error at this level as
# we will validation step afterwards.
#
kernel ClassifyBytes :: [BasisBits basis] -> [Lex lex] {
    # Brackets
    # 01 1 11 01 1 = {
    # 01 1 11 10 1 = }
    # 01 0 11 01 1 = [
    # 01 0 11 10 1 = ]

    temp1 = ~basis[7] & basis[6]
    temp2 = basis[3] & basis[4]
    temp3 = basis[0] & temp2
    # left
    temp4 = basis[1] & ~basis[2]
    # right
    temp5 = ~basis[1] & basis[2]
    # curly
    temp6 = basis[5] & temp3
    temp8 = temp1 & temp6
    lex.lCurly = temp8 & temp4
    lex.rCurly = temp8 & temp5
    # bracket
    temp9 = ~basis[5] & temp3
    temp10 = temp1 & temp9
    lex.lBracket = temp10 & temp4
    lex.rBracket = temp10 & temp5

    # 00 1 11 01 0 = :
    # 00 1 00 01 0 = "
    # 00 1 01 10 0 = ,

    temp11 = ~basis[7] & ~basis[6]
    temp12 = basis[5] & temp11
    temp13 = ~basis[0] & temp12
    temp14 = basis[1] & ~basis[2]
    temp15 = ~basis[1] & basis[2]
    # colon and quotes
    temp16 = temp13 & temp14
    temp17 = basis[3] & basis[4]
    lex.colon = temp17 & temp16
    temp18 = ~basis[3] & ~basis[4]
    lex.dQuote = temp18 & temp16
    # comma
    temp19 = temp13 & temp15
    temp20 = basis[3] & ~basis[4]
    lex.comma = temp19 & temp20

    # 00 1 01 10 1 = -
    temp21 = temp12 & temp20
    temp22 = temp21 & temp15
    lex.hyphen = basis[0] & temp22

    # [0-9]
    temp23 = basis[4] & basis[5]
    temp24 = basis[6] | basis[7]
    temp25 = temp23 & ~temp24
    temp26 = basis[1] | basis[2]
    temp27 = basis[3] & temp26
    temp28 = temp25 & ~temp27
    lex.digit = InFile(temp28)

    # 010 111 00 = \
    temp29 = temp1 & ~basis[5]
    temp30 = ~basis[1] & ~basis[0]
    temp32 = basis[3] & basis[2]
    temp34 = temp30 & temp32
    temp35 = basis[4] & temp34
    lex.backslash = temp29 & temp35

    # 011 01 1 1 0 = n
    # 011 00 1 1 0 = f
    # 011 10 1 0 0 = t
    temp38 = temp1 & basis[5]
    temp39 = ~basis[0] & basis[2]
    temp40 = temp39 & basis[1]
    temp41 = temp39 & ~basis[1]
    temp42 = temp20 & temp40
    lex.n = temp42 & temp38
    temp43 = temp18 & temp40
    lex.f = temp43 & temp38
    temp44 = ~basis[3] & basis[4]
    temp45 = temp44 & temp41
    lex.t = temp45 & temp38

    # [ \n\r\t]
    # 00 10 0000 = space
    # 00 00 1010 = lf
    # 00 00 1001 = tab
    # 00 00 1101 = cr
    temp46 = basis[0] & ~basis[1]
    temp47 = basis[4] | basis[5]
    temp48 = basis[6] | basis[7]
    temp49 = temp47 | temp48
    temp50 = basis[3] & temp46
    temp51 = ~temp49 & temp50
    temp52 = basis[2] | basis[3]
    temp31 = basis[0] | basis[1]
    temp53 = temp31 | temp52
    temp33 = basis[5] & ~basis[4]
    temp54 = ~temp48 & temp33
    temp55 = ~temp53 & temp54
    temp56 = temp51 | temp55
    lex.ws = InFile(temp56)
}

type U8Index = <i1>[1]

kernel UTF8_index_8x1 :: [BasisBits source] -> [U8Index u8index] {
    and = source[6] & source[7]
    Byte_c0_ff = InFile(and)
    nonFinal = Byte_c0_ff
    if Byte_c0_ff {
        or = source[2] | source[3]
        not = ~source[5]
        and_1 = and & not
        or_1 = source[1] | or
        or_2 = source[4] | or_1
        and_2 = and_1 & or_2
        Byte_c2_df = InFile(and_2)
        anyscope = <0>
        if Byte_c2_df {
            advance = Advance(Byte_c2_df, 1)
            anyscope = advance
        }
        or_3 = source[0] | source[1]
        not_1 = ~source[4]
        and_3 = source[5] & not_1
        and_4 = and & and_3
        Byte_e0_ef = InFile(and_4)
        EF_invalid = <0>
        if Byte_e0_ef {
            advance_1 = Advance(Byte_e0_ef, 1)
            or_4 = Byte_c0_ff | advance_1
            nonFinal = or_4
            advance_2 = Advance(Byte_e0_ef, 2)
            or_5 = advance_1 | advance_2
            or_6 = anyscope | or_5
            anyscope = or_6
            not_2 = ~source[1]
            or_7 = or_3 | or
            not_3 = ~or_7
            and_5 = and_4 & not_3
            Byte_e0 = InFile(and_5)
            advEO = Advance(Byte_e0, 1)
            not_4 = ~source[6]
            and_6 = source[7] & not_4
            and_7 = not & and_6
            Byte_80_9f = InFile(and_7)
            E0_invalid = advEO & Byte_80_9f
            and_8 = source[0] & not_2
            and_9 = source[2] & source[3]
            and_10 = and_8 & and_9
            and_11 = and_4 & and_10
            Byte_ed = InFile(and_11)
            advED = Advance(Byte_ed, 1)
            and_12 = source[5] & and_6
            Byte_a0_bf = InFile(and_12)
            ED_invalid = advED & Byte_a0_bf
            or_8 = E0_invalid | ED_invalid
            EF_invalid = or_8
        }
        not_5 = ~source[3]
        and_13 = source[4] & source[5]
        and_14 = and & and_13
        and_15 = not_5 & and_14
        and_16 = source[2] & or_3
        not_6 = ~and_16
        and_17 = and_15 & not_6
        Byte_f0_f4 = InFile(and_17)
        if Byte_f0_f4 {
            not_7 = ~or_3
            u8scope42 = Advance(Byte_f0_f4, 1)
            u8scope43 = Advance(u8scope42, 1)
            u8scope44 = Advance(u8scope43, 1)
            or_9 = u8scope42 | u8scope43
            or_10 = nonFinal | or_9
            nonFinal = or_10
            or_11 = u8scope44 | or_9
            or_12 = anyscope | or_11
            anyscope = or_12
            not_8 = ~source[6]
            or_13 = source[4] | source[5]
            not_9 = ~or_13
            and_18 = source[7] & not_8
            and_19 = not_9 & and_18
            Byte_80_8f = InFile(and_19)
            or_14 = or_3 | or
            not_10 = ~or_14
            and_20 = and_14 & not_10
            Byte_f0 = InFile(and_20)
            advance_3 = Advance(Byte_f0, 1)
            and_21 = Byte_80_8f & advance_3
            and_22 = or_13 & and_18
            Byte_90_bf = InFile(and_22)
            and_23 = source[2] & not_5
            and_24 = not_7 & and_23
            and_25 = and_14 & and_24
            Byte_f4 = InFile(and_25)
            advance_4 = Advance(Byte_f4, 1)
            and_26 = Byte_90_bf & advance_4
            or_15 = and_21 | and_26
            or_16 = EF_invalid | or_15
            EF_invalid = or_16
        }
        or_17 = Byte_c2_df | Byte_e0_ef
        or_18 = Byte_f0_f4 | or_17
        not_11 = ~source[6]
        and_27 = source[7] & not_11
        u8suffix = InFile(and_27)
        xor = anyscope ^ u8suffix
        xor_1 = Byte_c0_ff ^ or_18
        or_19 = EF_invalid | xor
        or_20 = xor_1 | or_19
        u8valid = ~or_20
        and_28 = nonFinal & u8valid
        nonFinal = and_28
    }
    not_12 = ~nonFinal
    inFile = InFile(not_12)
    u8index[0] = inFile
}

type StringMarker = <i1>[1]
type StringSpan = <i1>[1]

# TODO: See if we can get the string span not sequentially
#          json: { "key1": value1, "key2"  : null }
# input example: ..1....1..........1....1..........
#        output: ...1111............1111...........
#
kernel JSONStringSpan :: [StringMarker marker] -> [StringSpan span] {
    mStream = marker[0]
    endStream = <0>
    cursor = ScanTo(~Advance(<1>, 1), mStream)
    while cursor {
        nextPos = Advance(cursor, 1)
        endSpan = ScanTo(nextPos, mStream)
        endStream |= endSpan
        cursor = ScanTo(Advance(endSpan, 1), mStream)
    }
    beginStream = endStream ^ mStream
    inSpan = InclusiveSpan(beginStream, endStream)
    span[0] = inSpan
}

kernel LexLocations :: [Lex lex] -> [BasisBits output] {
    rOrLCurly = lex.lCurly | lex.rCurly
    rOrLBracket = lex.lBracket | lex.rBracket
    colonOrQuote = lex.colon | lex.dQuote
    colonQuoteOrComma = colonOrQuote | lex.comma
    or = rOrLBracket | rOrLCurly
    or2 = or | colonQuoteOrComma
    number = lex.hyphen | lex.digit
    trueOrFalse = lex.t | lex.f
    tfOrNull = trueOrFalse | lex.n
    numberOrKeyword = number | tfOrNull
    or3 = or2 | numberOrKeyword
    wsOrBs = lex.ws | lex.backslash
    or4 = or3 | wsOrBs
    output[0] = or4
    output[1] = or4
    output[2] = or4
    output[3] = or4
    output[4] = or4
    output[5] = or4
    output[6] = or4
    output[7] = or4
}

kernel SpanLocations :: [StringSpan span] -> [BasisBits output] {
    s = span[0]
    output[0] = s
    output[1] = ~s
    output[2] = ~s
    output[3] = ~s
    output[4] = s
    output[5] = ~s
    output[6] = s
    output[7] = s
}