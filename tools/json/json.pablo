#
# Copyright (c) 2019 International Characters.
# This software is licensed to the public under the Open Software License 3.0.
#

type BasisBits = <i1>[8]

type Err = <i1>[2] {
    escapedStr,
    utf8
}

type Lex = <i1>[14] {
    lCurly,
    rCurly,
    lBracket,
    rBracket,
    colon,
    comma,
    dQuote,
    hyphen,
    digit,
    backslash,
    n, # first letter of null
    f, # first letter of false
    t, # first letter of true
    ws
}

# ClassifyBytes the bytes of a basis stream.
# See that there is no error at this level as
# we will validation step afterwards.
#
kernel ClassifyBytes :: [BasisBits basis] -> [Lex lex] {
    # Brackets
    # 01 1 11 01 1 = {
    # 01 1 11 10 1 = }
    # 01 0 11 01 1 = [
    # 01 0 11 10 1 = ]

    temp1 = ~basis[7] & basis[6]
    temp2 = basis[3] & basis[4]
    temp3 = basis[0] & temp2
    # left
    temp4 = basis[1] & ~basis[2]
    # right
    temp5 = ~basis[1] & basis[2]
    # curly
    temp6 = basis[5] & temp3
    temp8 = temp1 & temp6
    lex.lCurly = temp8 & temp4
    lex.rCurly = temp8 & temp5
    # bracket
    temp9 = ~basis[5] & temp3
    temp10 = temp1 & temp9
    lex.lBracket = temp10 & temp4
    lex.rBracket = temp10 & temp5

    # 00 1 11 01 0 = :
    # 00 1 00 01 0 = "
    # 00 1 01 10 0 = ,

    temp11 = ~basis[7] & ~basis[6]
    temp12 = basis[5] & temp11
    temp13 = ~basis[0] & temp12
    temp14 = basis[1] & ~basis[2]
    temp15 = ~basis[1] & basis[2]
    # colon and quotes
    temp16 = temp13 & temp14
    temp17 = basis[3] & basis[4]
    lex.colon = temp17 & temp16
    temp18 = ~basis[3] & ~basis[4]
    lex.comma = temp18 & temp16
    # double quote
    temp19 = temp13 & temp15
    temp20 = basis[3] & ~basis[4]
    lex.dQuote = temp19 & temp20

    # 00 1 01 10 1 = -
    temp21 = temp12 & temp20
    temp22 = temp21 & temp15
    lex.hyphen = basis[0] & temp22

    # [0-9]
    temp23 = basis[4] & basis[5]
    temp24 = basis[6] | basis[7]
    temp25 = temp23 & ~temp24
    temp26 = basis[1] | basis[2]
    temp27 = basis[3] & temp26
    temp28 = temp25 & ~temp27
    lex.digit = InFile(temp28)

    # 010 111 00 = \
    temp29 = temp1 & ~basis[5]
    temp30 = ~basis[1] & ~basis[0]
    temp32 = basis[3] & basis[2]
    temp34 = temp30 & temp32
    temp35 = basis[4] & temp34
    lex.backslash = temp29 & temp35

    # 011 01 1 1 0 = n
    # 011 00 1 1 0 = f
    # 011 10 1 0 0 = t
    temp38 = temp1 & basis[5]
    temp39 = ~basis[0] & basis[2]
    temp40 = temp39 & basis[1]
    temp41 = temp39 & ~basis[1]
    temp42 = temp20 & temp40
    lex.n = temp42 & temp38
    temp43 = temp18 & temp40
    lex.f = temp43 & temp38
    temp44 = ~basis[3] & basis[4]
    temp45 = temp44 & temp41
    lex.t = temp45 & temp38

    # [ \n\r\t]
    # 00 10 0000 = space
    # 00 00 1010 = lf
    # 00 00 1001 = tab
    # 00 00 1101 = cr
    temp46 = basis[0] & ~basis[1]
    temp47 = basis[4] | basis[5]
    temp48 = basis[6] | basis[7]
    temp49 = temp47 | temp48
    temp50 = basis[3] & temp46
    temp51 = ~temp49 & temp50
    temp52 = basis[2] | basis[3]
    temp31 = basis[0] | basis[1]
    temp53 = temp31 | temp52
    temp33 = basis[5] & ~basis[4]
    temp54 = ~temp48 & temp33
    temp55 = ~temp53 & temp54
    temp56 = temp51 | temp55
    lex.ws = InFile(temp56)
}

kernel LexLocations :: [Lex lex] -> [BasisBits output] {
    rOrLCurly = lex.lCurly | lex.rCurly
    rOrLBracket = lex.lBracket | lex.rBracket
    colonOrQuote = lex.colon | lex.dQuote
    colonQuoteOrComma = colonOrQuote | lex.comma
    or = rOrLBracket | rOrLCurly
    or2 = or | colonQuoteOrComma
    number = lex.hyphen | lex.digit
    trueOrFalse = lex.t | lex.f
    tfOrNull = trueOrFalse | lex.n
    numberOrKeyword = number | tfOrNull
    or3 = or2 | numberOrKeyword
    wsOrBs = lex.ws | lex.backslash
    or4 = or3 | wsOrBs
    output[0] = or4
    output[1] = or4
    output[2] = or4
    output[3] = or4
    output[4] = or4
    output[5] = or4
    output[6] = or4
    output[7] = or4
}

type StringSpan = <i1>[1]

kernel SpanLocations :: [StringSpan span] -> [BasisBits output] {
    s = span[0]
    output[0] = s
    output[1] = ~s
    output[2] = ~s
    output[3] = ~s
    output[4] = s
    output[5] = ~s
    output[6] = s
    output[7] = s
}