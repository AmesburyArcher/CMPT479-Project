/*
 *  Copyright (c) 2019 International Characters.
 *  This software is licensed to the public under the Open Software License 3.0.
 *  icgrep is a trademark of International Characters.
 */

#include <pablo/compressed_carry_manager.h>

#include <pablo/carry_data.h>
#include <pablo/codegenstate.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/DataLayout.h>
#include <llvm/Transforms/Utils/Local.h>
#include <pablo/branch.h>
#include <pablo/pablo_intrinsic.h>
#include <pablo/pe_advance.h>
#include <pablo/pe_scanthru.h>
#include <pablo/pe_matchstar.h>
#include <pablo/pe_var.h>
#include <kernel/core/kernel_builder.h>
#include <toolchain/toolchain.h>
#include <array>

#if LLVM_VERSION_INTEGER < LLVM_VERSION_CODE(11, 0, 0)
    using FixedVectorType = llvm::VectorType;
#else
    using FixedVectorType = llvm::FixedVectorType;
#endif

enum NonCarryCollapsingMode {
    NestedCapacity = 0,
    LastIncomingCarryLoopIteration = 1,
    NestedCarryState = 2
};

#define LONG_ADVANCE_BREAKPOINT 64

using namespace llvm;

using BuilderRef = pablo::CompressedCarryManager::BuilderRef;

namespace pablo {

/* Local Helper Functions */

inline static bool isNonAdvanceCarryGeneratingStatement(const Statement * const stmt) {
    if (IntrinsicCall const * call = dyn_cast<IntrinsicCall>(stmt)) {
        return call->isCarryProducing() && !call->isAdvanceType();
    } else {
        return isa<CarryProducingStatement>(stmt) && !isa<Advance>(stmt) && !isa<IndexedAdvance>(stmt);
    }
}

static inline unsigned ceil_log2(const unsigned v) {
    assert ("log2(0) is undefined!" && v != 0);
    return (sizeof(unsigned) * CHAR_BIT) - __builtin_clz(v - 1U);
}


static inline unsigned nearest_pow2(const unsigned v) {
    assert (v > 0 && v < (UINT32_MAX / 2));
    return (v < 2) ? 1 : (1U << ceil_log2(v));
}


static inline unsigned ceil_udiv(const unsigned x, const unsigned y) {
    return (((x - 1) | (y - 1)) + 1) / y;
}

#ifndef NDEBUG
// Recursively determines the minimum summary size needed, in bits, for a given pablo block.
static int32_t analyseSummarySize(int32_t blockWidth, const PabloBlock * const scope) {
    int32_t carrySize = 0;
    for (const Statement * stmt : *scope) {
        if (LLVM_UNLIKELY(isa<Advance>(stmt) || isa<IndexedAdvance>(stmt))) {
            int64_t amount = isa<Advance>(stmt)
                ? cast<Advance>(stmt)->getAmount()
                : cast<IndexedAdvance>(stmt)->getAmount();
            if (LLVM_LIKELY(amount < 8)) {
                carrySize = std::max(8, carrySize);
            } else if (amount >= 8 && amount < LONG_ADVANCE_BREAKPOINT) {
                carrySize = std::max(64, carrySize);
            } else {
                carrySize = blockWidth;
            }
        } else if (LLVM_UNLIKELY(isNonAdvanceCarryGeneratingStatement(stmt))) {
            carrySize = std::max(8, carrySize);
        } else if (LLVM_UNLIKELY(isa<If>(stmt))) {
            carrySize = std::max(analyseSummarySize(blockWidth, cast<If>(stmt)->getBody()), carrySize);
        } else if (LLVM_UNLIKELY(isa<While>(stmt))) {
            carrySize = std::max(analyseSummarySize(blockWidth, cast<While>(stmt)->getBody()), carrySize);
        }
    }
    assert (carrySize >= 0 && carrySize <= blockWidth);
    return carrySize;
}
#endif

static Type * toSummaryType(BuilderRef b, int32_t summarySize) {
    switch (summarySize) {
    case 0:
        return nullptr;
    case 8:
        return b->getInt8Ty();
    case 64:
        return b->getInt64Ty();
    default:
        assert ("unexpected summary type" && (uint32_t) summarySize == b->getBitBlockWidth());
        return b->getBitBlockType();
    }
}

void CompressedCarryManager::enterIfScope(BuilderRef b) {
    ++mIfDepth;
    enterScope(b);
    // We zero-initialized the nested summary value and later OR in the current summary into the escaping summary
    // so that upon processing the subsequent block iteration, we branch into this If scope iff a carry out was
    // generated by a statement within this If scope and not by a dominating statement in the outer scope.
    if (mCarryInfo->hasExplicitSummary()) {
        Type * const summaryTy = getSummaryTypeFromCurrentFrame(b);
        mCarrySummaryStack.push_back(Constant::getNullValue(summaryTy)); // new carry out summary accumulator
    } else if (mCarryInfo->hasImplicitSummary()) {
        mCarrySummaryStack.push_back(convertFrameToImplicitSummaryPtr(b));
    }
}

inline unsigned getVectorBitWidth(Type * const ty) {
    #if LLVM_VERSION_INTEGER < LLVM_VERSION_CODE(11, 0, 0)
    return cast<FixedVectorType>(ty)->getPrimitiveSizeInBits();
    #else
    return cast<FixedVectorType>(ty)->getPrimitiveSizeInBits().getFixedSize();
    #endif
}

void CompressedCarryManager::combineCarryOutSummary(BuilderRef b, const unsigned offset) {
    if (LLVM_LIKELY(mCarryInfo->hasSummary())) {
        const auto n = mCarrySummaryStack.size(); assert (n > 0);
        // combine the outer summary with the nested summary so that when
        // we leave the scope, we'll properly phi out the value of the new
        // outer summary
        if (n > 2) {
            Value * nested = mCarrySummaryStack[n - 1];
            if (mCarryInfo->hasImplicitSummary()) {
                assert (nested->getType()->isPointerTy());
                nested = b->CreateLoad(nested);
            }
            Value * const outer = mCarrySummaryStack[n - 2];
            Type * const nestedTy = nested->getType();
            Type * const outerTy = outer->getType();
            if (nestedTy != outerTy) {
                if (nestedTy->canLosslesslyBitCastTo(outerTy)) {
                    nested = b->CreateZExtOrBitCast(nested, outerTy);
                } else {
                    if (nestedTy->isVectorTy()) {
                        IntegerType * const summaryTy = b->getIntNTy(getVectorBitWidth(nestedTy));
                        nested = b->CreateBitCast(nested, summaryTy);
                    }
                    assert (nested->getType()->isIntegerTy());
                    nested = b->CreateICmpNE(nested, Constant::getNullValue(nested->getType()));
                    assert (cast<IntegerType>(nested->getType())->getBitWidth() == 1);
                    if (outerTy->isIntegerTy()) {
                        nested = b->CreateZExt(nested, outerTy);
                    } else {
                        IntegerType * const summaryTy = b->getIntNTy(getVectorBitWidth(outerTy));
                        nested = b->CreateZExt(nested, summaryTy);
                        nested = b->CreateBitCast(nested, outerTy);
                    }
                }
            }
            assert (nested->getType() == outerTy);
            mCarrySummaryStack[n - offset] = b->CreateOr(outer, nested);
        }
    }
}

/* ===== Operations ===== */

/** ------------------------------------------------------------------------------------------------------------- *
 * @brief shortIndexedAdvanceCarryInCarryOut
 ** ------------------------------------------------------------------------------------------------------------- */
Value * CompressedCarryManager::shortIndexedAdvanceCarryInCarryOut(BuilderRef b, const unsigned shiftAmount, Value * const strm, Value * const index_strm) {
    Value * carryIn = getNextCarryIn(b);
    carryIn = b->CreateBitCast(b->CreateZExt(carryIn, b->getIntNTy(b->getBitBlockWidth())), b->getBitBlockType());
    Value * carryOut, * result;
    std::tie(carryOut, result) = b->bitblock_indexed_advance(strm, index_strm, carryIn, shiftAmount);
    const auto fw = (shiftAmount < 8) ? 8U : 64U;
    carryOut = b->mvmd_extract(fw, carryOut, 0);
    setNextCarryOut(b, carryOut);
    return result;
}

/* ===== Summary Operations ===== */

Value * CompressedCarryManager::readCarryInSummary(BuilderRef b) const {
    assert (mCarryInfo->hasSummary());
    if (LLVM_LIKELY(mCarryInfo->hasImplicitSummary())) {
        return b->CreateLoad(convertFrameToImplicitSummaryPtr(b));
    } else {
        assert (mCarryInfo->hasExplicitSummary());
        Value * ptr = nullptr;
        Constant * const ZERO = b->getInt32(0);
        FixedArray<Value *, 3> indices;
        indices[0] = ZERO;
        indices[1] = ZERO;
        indices[2] = mLoopDepth == 0 ? ZERO : mLoopSelector;
        ptr = b->CreateGEP(mCurrentFrame, indices);
        Value * summary = b->CreateLoad(ptr);
        if (mNestedLoopCarryInMaskPhi) {
            summary = b->CreateAnd(summary, mNestedLoopCarryInMaskPhi);
        }
        return summary;
    }
}

Value * CompressedCarryManager::convertFrameToImplicitSummaryPtr(BuilderRef b) const {
    assert (mCarryInfo->hasImplicitSummary());
    return b->CreatePointerCast(mCurrentFrame, mCarryInfo->getSummarySizeTy()->getPointerTo());
}

Type * CompressedCarryManager::getSummaryTypeFromCurrentFrame(BuilderRef b) const {
    return mCarryInfo->getSummarySizeTy();
}

/* ==== Scope Analyse ===== */
StructType * CompressedCarryManager::analyse(BuilderRef b,
                                             const PabloBlock * const scope,
                                             const unsigned ifDepth,
                                             const unsigned whileDepth,
                                             const bool inNonCarryCollapsingLoop)
{
    assert ("scope cannot be null!" && scope);
    assert ("entry scope (and only the entry scope) must be in scope 0"
            && (mCarryScopes == 0 ? (scope == mKernel->getEntryScope()) : (scope != mKernel->getEntryScope())));
    assert (mCarryScopes < mCarryMetadata.size());

    Type * const i8Ty = b->getInt8Ty();
    Type * const i64Ty = b->getInt64Ty();
    Type * const blockTy = b->getBitBlockType();
    const auto blockWidth = b->getBitBlockWidth();

    const auto carryScopeIndex = mCarryScopes++;

    const uint64_t packSize = whileDepth == 0 ? 1 : 2;
    Type * const i8PackTy = ArrayType::get(i8Ty, packSize);
    Type * const i64PackTy = ArrayType::get(i64Ty, packSize);

    bool canUseImplicitSummary = (packSize == 1) && !inNonCarryCollapsingLoop;
    size_t carryProducingStatementCount = 0;
    const auto maxNumSmallCarriesForImplicitSummary = blockWidth / 8;

    /* Get Carry Types */

    auto getNestedSummarySize = [&](const unsigned nestedScopeIndex) -> unsigned {
        assert (nestedScopeIndex < mCarryMetadata.size());
        Type * const ty = mCarryMetadata[nestedScopeIndex].getSummarySizeTy();
        if (LLVM_UNLIKELY(ty == nullptr)) {
            return 0U;
        } else if (ty->isIntegerTy()) {
            return cast<IntegerType>(ty)->getBitWidth();
        } else {
            return getVectorBitWidth(ty);
        }
    };

    unsigned summarySize = 0;

    std::vector<Type *> state;
    for (const Statement * stmt : *scope) {
        if (LLVM_UNLIKELY(isa<Advance>(stmt) || isa<IndexedAdvance>(stmt))) {
            const auto amount = isa<Advance>(stmt)
                ? cast<Advance>(stmt)->getAmount()
                : cast<IndexedAdvance>(stmt)->getAmount();

            Type * type = nullptr;
            if (LLVM_LIKELY(amount < 8)) {
                type = i8PackTy;
                summarySize = std::max(8U, summarySize);
                ++carryProducingStatementCount;
            } else if (LLVM_UNLIKELY(amount < LONG_ADVANCE_BREAKPOINT)) {
                canUseImplicitSummary = false;
                type = i64PackTy;
                summarySize = std::max(64U, summarySize);
            } else {
                canUseImplicitSummary = false;
                const auto blockWidth = b->getBitBlockWidth();
                const auto blocks = ceil_udiv(amount, blockWidth);
                type = ArrayType::get(blockTy, nearest_pow2(blocks + (isa<IndexedAdvance>(stmt) ? 1:0) + ((whileDepth != 0) ? 1 : 0)));
                if (LLVM_UNLIKELY(ifDepth > 0 && blocks != 1)) {
                    const auto summarySize = ceil_udiv(blocks, blockWidth);
                    // 1 bit will mark the presense of any bit in each block.
                    state.push_back(ArrayType::get(blockTy, summarySize));
                }
                mHasLongAdvance = true;
                if (isa<IndexedAdvance>(stmt)) {
                    mIndexedLongAdvanceTotal++;
                }
                summarySize = blockWidth;
            }
            state.push_back(type);
        } else if (LLVM_UNLIKELY(isNonAdvanceCarryGeneratingStatement(stmt))) {
            ++carryProducingStatementCount;
            summarySize = std::max(8U, summarySize);
            state.push_back(i8PackTy);
        } else if (LLVM_UNLIKELY(isa<If>(stmt))) {
            canUseImplicitSummary = false;
            const auto nestedScopeIndex = mCarryScopes;
            state.push_back(analyse(b, cast<If>(stmt)->getBody(), ifDepth + 1, whileDepth, false));
            summarySize = std::max(getNestedSummarySize(nestedScopeIndex), summarySize);
        } else if (LLVM_UNLIKELY(isa<While>(stmt))) {
            canUseImplicitSummary = false;
            mHasLoop = true;
            const auto nestedScopeIndex = mCarryScopes;
            const PabloBlock * const nestedScope = cast<While>(stmt)->getBody();
            const auto carryCollapsingMode = cast<While>(stmt)->isRegular();
            state.push_back(analyse(b, nestedScope, ifDepth, whileDepth + 1, !carryCollapsingMode));
            summarySize = std::max(getNestedSummarySize(nestedScopeIndex), summarySize);
        }
    }

    if (carryProducingStatementCount > maxNumSmallCarriesForImplicitSummary) {
        canUseImplicitSummary = false;
    }

    /* Construct Carry State Struct */
    CarryData & cd = mCarryMetadata[carryScopeIndex];
    StructType * carryState = nullptr;
    CarryData::SummaryType summaryType = CarryData::NoSummary;

    Type * const summaryTy = toSummaryType(b, summarySize);

    // if we have at least one non-empty carry state, check if we need a summary
    if (LLVM_UNLIKELY(isEmptyCarryStruct(state) || inNonCarryCollapsingLoop)) {
        carryState = StructType::get(b->getContext(), state);
    } else {
        if (LLVM_LIKELY(ifDepth > 0 || whileDepth > 0)) {
            if (LLVM_LIKELY(canUseImplicitSummary)) {
                summaryType = CarryData::ImplicitSummary;
                // If needed, pad the structure to 64 bits or the bitblock width. This allows us to bitcast the structure to an i64 or
                // bitblock to get the summary.
                carryState = StructType::get(b->getContext(), state);
                const DataLayout & DL = b->getModule()->getDataLayout();
                const auto stateSize = DL.getTypeAllocSize(carryState) * 8;
                if (stateSize < summarySize) {
                    const auto padding = summarySize - stateSize;
                    assert ((padding % 8) == 0);
                    ArrayType * const paddingTy = ArrayType::get(i8Ty, padding / 8);
                    state.push_back(paddingTy);
                }

                carryState = StructType::get(b->getContext(), state);

                // summaryTy = (targetWidth == 64) ? (Type *) b->getInt64Ty() : b->getBitBlockType();
            } else {
                summaryType = CarryData::ExplicitSummary;
                // Insert the smallest possible summary for this scope.
                assert (summarySize == analyseSummarySize((int32_t) blockWidth, scope));
                state.insert(state.begin(), ArrayType::get(summaryTy, packSize));
            }
        }

        carryState = StructType::get(b->getContext(), state);
    }

    if (LLVM_UNLIKELY(inNonCarryCollapsingLoop && state.size() > 0)) {
        mHasNonCarryCollapsingLoops = true;
        summaryType = (CarryData::SummaryType)(CarryData::ExplicitSummary | CarryData::NonCarryCollapsingMode);
        FixedArray<Type *, 3> fields;
        fields[NestedCapacity] = b->getSizeTy();
        fields[LastIncomingCarryLoopIteration] = b->getSizeTy();
        fields[NestedCarryState] = carryState->getPointerTo();
        carryState = StructType::get(b->getContext(), fields);
    }
    cd.setSummarySizeTy(summaryTy);
    cd.setSummaryType(summaryType);
    return carryState;
}

CompressedCarryManager::CompressedCarryManager() noexcept
: CarryManager()
{}


} // namespace pablo
